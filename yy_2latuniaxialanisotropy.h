/** FILE: yy_2latuniaxialanisotropy.h            -*-Mode: c++-*-
 *
 * Uniaxial Anisotropy for two-lattice simulations. Based on 
 * uniaxialanisotropy.cc.
 *
 * Copyright (C) 2015 Yu Yahagi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#ifndef _YY_2LATUNIAXIALANISOTROPY
#define _YY_2LATUNIAXIALANISOTROPY

#include "nb.h"
#include "threevector.h"
#include "util.h"
#include "chunkenergy.h"
#include "energy.h"
#include "key.h"
#include "simstate.h"
#include "mesh.h"
#include "meshvalue.h"
#include "oxsthread.h"
#include "scalarfield.h"
#include "vectorfield.h"

/* End includes */

class YY_2LatUniaxialAnisotropy
  : public Oxs_ChunkEnergy, public Oxs_EnergyPreconditionerSupport {
private:
  enum AnisotropyCoefType {
    ANIS_UNKNOWN, K1_TYPE, Ha_TYPE
  } aniscoeftype;

  Oxs_OwnedPointer<Oxs_ScalarField> K11_init, K12_init;
  Oxs_OwnedPointer<Oxs_ScalarField> Ha1_init, Ha2_init;
  Oxs_OwnedPointer<Oxs_VectorField> axis1_init, axis2_init;
  mutable Oxs_ThreadControl thread_control;
  mutable OC_UINT4m mesh_id;
  mutable Oxs_MeshValue<OC_REAL8m> K11, K12;
  mutable Oxs_MeshValue<OC_REAL8m> Ha1, Ha2;
  mutable Oxs_MeshValue<ThreeVector> axis1, axis2;
  /// K1, Ha, and axis are cached values filled by corresponding
  /// *_init members when a change in mesh is detected.

  // It is not uncommon for the anisotropy to be specified by uniform
  // fields.  In this case, memory traffic can be significantly
  // reduced, which may be helpful in parallelized code.  The
  // variables uniform_K1/Ha/axis_value are valid iff the corresponding
  // boolean is true.
  OC_BOOL K11_is_uniform, K12_is_uniform;
  OC_BOOL Ha1_is_uniform, Ha2_is_uniform;
  OC_BOOL axis1_is_uniform, axis2_is_uniform;
  OC_REAL8m uniform_K11_value, uniform_K12_value;
  OC_REAL8m uniform_Ha1_value, uniform_Ha2_value;
  ThreeVector uniform_axis1_value, uniform_axis2_value;

  enum IntegrationMethod {
    UNKNOWN_INTEG, RECT_INTEG, QUAD_INTEG
  } integration_method;
  /// Integration formulation to use.  "unknown" is invalid; it
  /// is defined for error detection.

  // RectIntegEnergy is a helper function for ComputeEnergyChunk;
  // it computes using "RECT_INTEG" method.
  void RectIntegEnergy(const Oxs_SimState& state,
                       Oxs_ComputeEnergyDataThreaded& ocedt,
                       Oxs_ComputeEnergyDataThreadedAux& ocedtaux,
                       OC_INDEX node_start,OC_INDEX node_stop) const;


  OC_BOOL has_multscript;
  vector<Nb_TclCommandLineOption> command_options;
  Nb_TclCommand cmd;
  OC_UINT4m number_of_stages;

  // Variables to track and store multiplier value for each simulation
  // state.  This data is computed once per state by the main thread,
  // and shared with all the children.
  mutable Oxs_ThreadControl mult_thread_control;
  mutable OC_UINT4m mult_state_id;
  mutable OC_REAL8m mult;
  mutable OC_REAL8m dmult; // Partial derivative of multiplier wrt t

  void GetMultiplier(const Oxs_SimState& state,
                     OC_REAL8m& mult,
                     OC_REAL8m& dmult) const;

protected:
  virtual void GetEnergy(const Oxs_SimState& state,
			 Oxs_EnergyData& oed) const {
    GetEnergyAlt(state,oed);
  }

  virtual void ComputeEnergy(const Oxs_SimState& state,
                             Oxs_ComputeEnergyData& oced) const {
    ComputeEnergyAlt(state,oced);
  }

  virtual void ComputeEnergyChunk(const Oxs_SimState& state,
                                  Oxs_ComputeEnergyDataThreaded& ocedt,
                                  Oxs_ComputeEnergyDataThreadedAux& ocedtaux,
                                  OC_INDEX node_start,OC_INDEX node_stop,
                                  int threadnumber) const;
public:
  virtual const char* ClassName() const; // ClassName() is
  /// automatically generated by the OXS_EXT_REGISTER macro.
  YY_2LatUniaxialAnisotropy(const char* name,  // Child instance id
			 Oxs_Director* newdtr, // App director
			 const char* argstr);  // MIF input block parameters
  virtual ~YY_2LatUniaxialAnisotropy() {}
  virtual OC_BOOL Init();
  virtual void StageRequestCount(unsigned int& min,
				 unsigned int& max) const;

  // Optional interface for conjugate-gradient evolver.
  virtual int IncrementPreconditioner(PreconditionerData& pcd);
};


#endif // _YY_2LATUNIAXIALANISOTROPY
